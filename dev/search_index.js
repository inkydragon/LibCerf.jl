var documenterSearchIndex = {"docs":
[{"location":"#LibCerf","page":"Home","title":"LibCerf","text":"Documentation for LibCerf.\n\n","category":"section"},{"location":"#LibCerf.LibCerf","page":"Home","title":"LibCerf.LibCerf","text":"LibCerf\n\nA Julia wrapper for the libcerf library.\n\nlibcerf, a self-contained numeric library that provides an efficient and accurate implementation of complex error functions, along with Dawson, Faddeeva, and Voigt functions.\n\nExported functions\n\nerf(z):     Complex error function\nerfc(z):    Complementary error function\nerfcx(z), erfcx(x):   Underflow-compensated complementary error function\nerfi(z), erfi(x):   Imaginary error function\nfaddeeva_w(z):  Faddeeva's scaled complex error function\nim_w(x):        imaginary part of faddeeva_w(complex(x, 0.0))\nim_w(re, im):   imaginary part of faddeeva_w(complex(re, im))\nre_w(re, im):   real part of faddeeva_w(complex(re, im))\ndawson(z), dawson(x): Dawson's integral\nvoigt(x, sigma, gamma):   Voigt's convolution of a Gaussian and a Lorentzian\nvoigt_hwhm(sigma, gamma):   Half width at half maximum of the Voigt profile\n\nReferences\n\nS. G. Johnson, J. Wuttke: libcerf, numeric library for complex error functions,   https://jugit.fz-juelich.de/mlz/libcerf\n\n\n\n\n\n","category":"module"},{"location":"#LibCerf.dawson","page":"Home","title":"LibCerf.dawson","text":"dawson(x)\ndawson(z)\n\nDawson integral of real or complex arguments.\n\ntextDawson(z)\n= e^-z^2 int_0^z e^t^2 dt\n= fracsqrtpi2 e^-z^2 texterfi(z)\n\nExamples\n\njulia> [ (x=x, dawson=Float32(dawson(x))) for x in -2:0.5:2 ]\n9-element Vector{@NamedTuple{x::Float64, dawson::Float32}}:\n (x = -2.0, dawson = -0.3013404)\n (x = -1.5, dawson = -0.42824906)\n (x = -1.0, dawson = -0.5380795)\n (x = -0.5, dawson = -0.4244364)\n (x = 0.0, dawson = 0.0)\n (x = 0.5, dawson = 0.4244364)\n (x = 1.0, dawson = 0.5380795)\n (x = 1.5, dawson = 0.42824906)\n (x = 2.0, dawson = 0.3013404)\n\njulia> [ (x=x, dawson=dawson(x)) for x in (-Inf, -0.0, 0.0, Inf) ]\n4-element Vector{@NamedTuple{x::Float64, dawson::Float64}}:\n (x = -Inf, dawson = -0.0)\n (x = -0.0, dawson = -0.0)\n (x = 0.0, dawson = 0.0)\n (x = Inf, dawson = 0.0)\n\njulia> abs( dawson(complex(pi)) - sqrt(pi)/2*exp(-pi^2)*erfi(complex(pi)) ) < eps(Float64)\ntrue\n\nSee also: erfi(z)\n\nReferences\n\nDLMF: §7.2.5\nDawson's Integral – Wolfram MathWorld\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.erf","page":"Home","title":"LibCerf.erf","text":"erf(z)\n\nError function of complex arguments.\n\ntexterf(z) = frac2sqrtpi int_0^z e^-t^2 dt\n\nExamples\n\njulia> [ (x=x, erf=Float32(erf(complex(x)))) for x in -2:0.5:2 ]\n9-element Vector{@NamedTuple{x::Float64, erf::Float32}}:\n (x = -2.0, erf = -0.9953223)\n (x = -1.5, erf = -0.96610516)\n (x = -1.0, erf = -0.8427008)\n (x = -0.5, erf = -0.5204999)\n (x = 0.0, erf = 0.0)\n (x = 0.5, erf = 0.5204999)\n (x = 1.0, erf = 0.8427008)\n (x = 1.5, erf = 0.96610516)\n (x = 2.0, erf = 0.9953223)\n\njulia> [ (x=x, erf=erf(complex(x))) for x in (-Inf, -0.0, 0.0, Inf) ]\n4-element Vector{@NamedTuple{x::Float64, erf::ComplexF64}}:\n (x = -Inf, erf = -1.0 + 0.0im)\n (x = -0.0, erf = -0.0 + 0.0im)\n (x = 0.0, erf = 0.0 + 0.0im)\n (x = Inf, erf = 1.0 + 0.0im)\n\njulia> erf(complex(3.14)) + erfc(complex(3.14))\n1.0 + 0.0im\n\nSee also: erfc(z), erfcx(z), erfi(z)\n\nReferences\n\nDLMF: §7.2.1\nErf – Wolfram MathWorld\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.erfc","page":"Home","title":"LibCerf.erfc","text":"erfc(z)\n\nComplementary error function of complex arguments.\n\ntexterfc(z)\n= frac2sqrtpi int_z^infty e^-t^2 dt\n= 1 - texterf(z)\n\nExamples\n\njulia> [ (x=x, erfc=Float32(erfc(complex(x)))) for x in -2:0.5:2 ]\n9-element Vector{@NamedTuple{x::Float64, erfc::Float32}}:\n (x = -2.0, erfc = 1.9953222)\n (x = -1.5, erfc = 1.9661051)\n (x = -1.0, erfc = 1.8427008)\n (x = -0.5, erfc = 1.5204998)\n (x = 0.0, erfc = 1.0)\n (x = 0.5, erfc = 0.47950011)\n (x = 1.0, erfc = 0.1572992)\n (x = 1.5, erfc = 0.03389485)\n (x = 2.0, erfc = 0.004677735)\n\njulia> [ (x=x, erfc=erfc(complex(x))) for x in (-Inf, 0.0, Inf) ]\n3-element Vector{@NamedTuple{x::Float64, erfc::ComplexF64}}:\n (x = -Inf, erfc = 2.0 - 0.0im)\n (x = 0.0, erfc = 1.0 - 0.0im)\n (x = Inf, erfc = 0.0 - 0.0im)\n\njulia> erf(complex(3.141)) + erfc(complex(3.141))\n1.0 + 0.0im\n\nSee also: erf(z), erfcx(z)\n\nReferences\n\nDLMF: §7.2.2\nErfc – Wolfram MathWorld\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.erfcx","page":"Home","title":"LibCerf.erfcx","text":"erfcx(x)\nerfcx(z)\n\nUnderflow-compensated complementary error function of real or complex arguments.\n\ntexterfcx(z)\n= exp(z^2) texterfc(z)\n= w(iz)\n\nExamples\n\njulia> [ (x=x, erfcx=Float32(erfcx(complex(x)))) for x in -2:0.5:2 ]\n9-element Vector{@NamedTuple{x::Float64, erfcx::Float32}}:\n (x = -2.0, erfcx = 108.9409)\n (x = -1.5, erfcx = 18.653887)\n (x = -1.0, erfcx = 5.0089803)\n (x = -0.5, erfcx = 1.9523605)\n (x = 0.0, erfcx = 1.0)\n (x = 0.5, erfcx = 0.61569035)\n (x = 1.0, erfcx = 0.42758358)\n (x = 1.5, erfcx = 0.32158542)\n (x = 2.0, erfcx = 0.25539568)\n\njulia> [ (x=x, erfcx=erfcx(complex(x))) for x in (-Inf, 0.0, Inf) ]\n3-element Vector{@NamedTuple{x::Float64, erfcx::ComplexF64}}:\n (x = -Inf, erfcx = Inf - 0.0im)\n (x = 0.0, erfcx = 1.0 - 0.0im)\n (x = Inf, erfcx = 0.0 - 0.0im)\n\njulia> erfcx(complex(pi)) - exp(pi^2)*erfc(complex(pi))\n0.0 + 0.0im\n\njulia> erfcx(complex(pi)) - faddeeva_w(im * complex(pi))\n0.0 - 0.0im\n\nSee also: erf(z), erfc(z)\n\nReferences\n\nFaddeeva Package\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.erfi","page":"Home","title":"LibCerf.erfi","text":"erfi(x)\nerfi(z)\n\nImaginary error function of real or complex arguments.\n\ntexterfi(z) = -i texterf(iz)\n\nExamples\n\njulia> [ (x=x, erfi=Float32(erfi(complex(x)))) for x in -2:0.5:2 ]\n9-element Vector{@NamedTuple{x::Float64, erfi::Float32}}:\n (x = -2.0, erfi = -18.564802)\n (x = -1.5, erfi = -4.5847335)\n (x = -1.0, erfi = -1.6504258)\n (x = -0.5, erfi = -0.6149521)\n (x = 0.0, erfi = 0.0)\n (x = 0.5, erfi = 0.6149521)\n (x = 1.0, erfi = 1.6504258)\n (x = 1.5, erfi = 4.5847335)\n (x = 2.0, erfi = 18.564802)\n\njulia> [ (x=x, erfi=erfi(complex(x))) for x in (-Inf, -0.0, 0.0, Inf) ]\n4-element Vector{@NamedTuple{x::Float64, erfi::ComplexF64}}:\n (x = -Inf, erfi = -Inf + 0.0im)\n (x = -0.0, erfi = -0.0 + 0.0im)\n (x = 0.0, erfi = 0.0 + 0.0im)\n (x = Inf, erfi = Inf + 0.0im)\n\njulia> erfi(complex(pi)) + im*erf(im*complex(pi))\n0.0 + 0.0im\n\nSee also: erf(z)\n\nReferences\n\nErfi – Wolfram MathWorld\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.faddeeva_w","page":"Home","title":"LibCerf.faddeeva_w","text":"faddeeva_w(z)\n\nFaddeeva's scaled complex error function of complex arguments.\n\nw(z)\n= e^-z^2 texterfc(-iz)\n= texterfcx(-iz)\n\nExamples\n\njulia> [ (x=x, w=ComplexF16(faddeeva_w(complex(x)))) for x in -2:0.5:2 ]\n9-element Vector{@NamedTuple{x::Float64, w::ComplexF16}}:\n (x = -2.0, w = Float16(0.01831) - Float16(0.34)im)\n (x = -1.5, w = Float16(0.1054) - Float16(0.4832)im)\n (x = -1.0, w = Float16(0.368) - Float16(0.607)im)\n (x = -0.5, w = Float16(0.779) - Float16(0.479)im)\n (x = 0.0, w = Float16(1.0) + Float16(0.0)im)\n (x = 0.5, w = Float16(0.779) + Float16(0.479)im)\n (x = 1.0, w = Float16(0.368) + Float16(0.607)im)\n (x = 1.5, w = Float16(0.1054) + Float16(0.4832)im)\n (x = 2.0, w = Float16(0.01831) + Float16(0.34)im)\n\njulia> [ (x=x, w=faddeeva_w(complex(x))) for x in (-Inf, -0.0, 0.0, Inf) ]\n4-element Vector{@NamedTuple{x::Float64, w::ComplexF64}}:\n (x = -Inf, w = 0.0 - 0.0im)\n (x = -0.0, w = 1.0 - 0.0im)\n (x = 0.0, w = 1.0 + 0.0im)\n (x = Inf, w = 0.0 + 0.0im)\n\njulia> faddeeva_w(complex(pi)) - erfcx(-im * complex(pi))\n0.0 + 0.0im\n\nSee also: erfc(z), erfcx(z)\n\nReferences\n\nDLMF: §7.2.3\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.im_w","page":"Home","title":"LibCerf.im_w","text":"im_w(x)\nim_w(re, im)\n\nImaginary part of Faddeeva's scaled complex error function of real arguments.\n\nim_w(x) = imag( faddeeva_w(complex(x, 0.0)) )\nim_w(re, im) = imag( faddeeva_w(complex(re, im)) )\n\nExamples\n\njulia> [ (x=x, w=Float32(im_w(x, 0.0))) for x in -2:0.5:2 ]\n9-element Vector{@NamedTuple{x::Float64, w::Float32}}:\n (x = -2.0, w = -0.34002623)\n (x = -1.5, w = -0.48322734)\n (x = -1.0, w = -0.6071577)\n (x = -0.5, w = -0.47892517)\n (x = 0.0, w = 0.0)\n (x = 0.5, w = 0.47892517)\n (x = 1.0, w = 0.6071577)\n (x = 1.5, w = 0.48322734)\n (x = 2.0, w = 0.34002623)\n\njulia> [ (x=x, w_im=im_w(x)) for x in (-Inf, -0.0, 0.0, Inf) ]\n4-element Vector{@NamedTuple{x::Float64, w_im::Float64}}:\n (x = -Inf, w_im = -0.0)\n (x = -0.0, w_im = -0.0)\n (x = 0.0, w_im = 0.0)\n (x = Inf, w_im = 0.0)\n\njulia> faddeeva_w(3.14+0im) - complex(re_w(3.14,0.0), im_w(3.14))\n0.0 + 0.0im\n\nSee also: faddeeva_w(z), re_w(re, im)\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.re_w","page":"Home","title":"LibCerf.re_w","text":"re_w(re, im)\n\nReal part of Faddeeva's scaled complex error function of real arguments.\n\nre_w(re, im) = real( faddeeva_w(complex(re, im)) )\n\nExamples\n\njulia> [ (x=x, w=Float32(re_w(x, 0.0))) for x in -2:0.5:2 ]\n9-element Vector{@NamedTuple{x::Float64, w::Float32}}:\n (x = -2.0, w = 0.01831564)\n (x = -1.5, w = 0.10539922)\n (x = -1.0, w = 0.36787945)\n (x = -0.5, w = 0.7788008)\n (x = 0.0, w = 1.0)\n (x = 0.5, w = 0.7788008)\n (x = 1.0, w = 0.36787945)\n (x = 1.5, w = 0.10539922)\n (x = 2.0, w = 0.01831564)\n\njulia> [ (x=x, w_im=re_w(x, 0.0)) for x in (-Inf, 0.0, Inf) ]\n3-element Vector{@NamedTuple{x::Float64, w_im::Float64}}:\n (x = -Inf, w_im = 0.0)\n (x = 0.0, w_im = 1.0)\n (x = Inf, w_im = 0.0)\n\njulia> faddeeva_w(1.0+2.0im) - complex(re_w(1.0,2.0), im_w(1.0,2.0))\n0.0 + 0.0im\n\nSee also: faddeeva_w(z), im_w(re, im)\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.voigt","page":"Home","title":"LibCerf.voigt","text":"voigt(x, sigma, gamma)\n\nConvolution of a Gaussian and a Lorentzian of real arguments.\n\ntextVoigt(x sigma gamma)\n= int_-infty^infty G(t sigma) L(x-t gamma) dt\n\nwhere\n\nG(x sigma) = frac1sigmasqrt2pi exp(-fracx^22sigma^2)\n\nL(x gamma) = frac gamma  pi(x^2+gamma^2) \n\nExamples\n\njulia> [ (x=x, voigt=Float32(voigt(x, 1.0, 0.0))) for x in -10:2.0:10 ]\n11-element Vector{@NamedTuple{x::Float64, voigt::Float32}}:\n (x = -10.0, voigt = 7.6945985f-23)\n (x = -8.0, voigt = 5.052271f-15)\n (x = -6.0, voigt = 6.075883f-9)\n (x = -4.0, voigt = 0.00013383022)\n (x = -2.0, voigt = 0.053990968)\n (x = 0.0, voigt = 0.3989423)\n (x = 2.0, voigt = 0.053990968)\n (x = 4.0, voigt = 0.00013383022)\n (x = 6.0, voigt = 6.075883f-9)\n (x = 8.0, voigt = 5.052271f-15)\n (x = 10.0, voigt = 7.6945985f-23)\n\njulia> [ (x=x, voigt=Float32(voigt(x, 0.0, 3.0))) for x in -10:2.0:10 ]\n11-element Vector{@NamedTuple{x::Float64, voigt::Float32}}:\n (x = -10.0, voigt = 0.008760823)\n (x = -8.0, voigt = 0.013081228)\n (x = -6.0, voigt = 0.02122066)\n (x = -4.0, voigt = 0.038197186)\n (x = -2.0, voigt = 0.07345613)\n (x = 0.0, voigt = 0.10610329)\n (x = 2.0, voigt = 0.07345613)\n (x = 4.0, voigt = 0.038197186)\n (x = 6.0, voigt = 0.02122066)\n (x = 8.0, voigt = 0.013081228)\n (x = 10.0, voigt = 0.008760823)\n\njulia> [ (x=x, voigt=Float32(voigt(x, 1.0, 0.5))) for x in (-Inf, 0.0, Inf) ]\n3-element Vector{@NamedTuple{x::Float64, voigt::Float32}}:\n (x = -Inf, voigt = 0.0)\n (x = 0.0, voigt = 0.27895546)\n (x = Inf, voigt = 0.0)\n\nSee also: faddeeva_w(z), voigt_hwhm(sigma, gamma)\n\nReferences\n\nVoigt profile - Wikipedia\n\n\n\n\n\n","category":"function"},{"location":"#LibCerf.voigt_hwhm","page":"Home","title":"LibCerf.voigt_hwhm","text":"voigt_hwhm(sigma, gamma)\n\nHalf width at half maximum of the Voigt function of real arguments.\n\nIt is implicitly defined by:\n\ntextVoigt( textVoigtHWHM( sigma gamma) sigma gamma)\n= frac12 textVoigt(0 sigma gamma)\n\nExamples\n\njulia> σ, γ = 1.3, 0.5;\n\njulia> [ (x=x, voigt=Float32(voigt(x, σ, γ))) for x in -10:3.0:10 ]\n7-element Vector{@NamedTuple{x::Float64, voigt::Float32}}:\n (x = -10.0, voigt = 0.0016752308)\n (x = -7.0, voigt = 0.0036378063)\n (x = -4.0, voigt = 0.016749112)\n (x = -1.0, voigt = 0.18637252)\n (x = 2.0, voigt = 0.100623265)\n (x = 5.0, voigt = 0.008416025)\n (x = 8.0, voigt = 0.0027030057)\n\njulia> Float32(voigt(0.0, σ, γ))    # peak\n0.23147874f0\n\njulia> Float32(voigt(0.0, σ, γ)) / 2  # half peak\n0.11573937f0\n\njulia> hwhm_x = voigt_hwhm(σ, γ);   # here voigt takes exactly half the peak value\n\njulia> voigt(hwhm_x, σ, γ) - voigt(0.0, σ, γ)/2\n0.0\n\nSee also: voigt(x, sigma, gamma)\n\nReferences\n\nWuttke, J. (2025). Power series for the half width of the Voigt function, rederived.   Journal of Numerical Analysis and Approximation Theory, 54(2), 345-356.   https://doi.org/10.33993/jnaat542-1640\n\n\n\n\n\n","category":"function"}]
}
